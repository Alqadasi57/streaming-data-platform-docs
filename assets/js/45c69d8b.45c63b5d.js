"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6960],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>y});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},f=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(r),f=n,y=u["".concat(l,".").concat(f)]||u[f]||d[f]||i;return r?a.createElement(y,o(o({ref:t},p),{},{components:r})):a.createElement(y,o({ref:t},p))}));function y(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:n,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}f.displayName="MDXCreateElement"},49790:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=r(87462),n=(r(67294),r(3905));const i={sidebar_position:2},o="Query Fact Records",s={unversionedId:"graphql/capabilities/query_fact_records",id:"graphql/capabilities/query_fact_records",title:"Query Fact Records",description:"This is the simplest type of query. You just define the attributes which you need in the results,",source:"@site/docs/graphql/capabilities/query_fact_records.md",sourceDirName:"graphql/capabilities",slug:"/graphql/capabilities/query_fact_records",permalink:"/docs/graphql/capabilities/query_fact_records",draft:!1,editUrl:"https://github.com/bitquery/streaming-data-platform-docs/tree/main/docs/graphql/capabilities/query_fact_records.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Usage Patterns",permalink:"/docs/graphql/capabilities/patterns"},next:{title:"Query Aggregated Metrics",permalink:"/docs/graphql/capabilities/aggregated_metrics"}},l={},c=[],p={toc:c},u="wrapper";function d(e){let{components:t,...r}=e;return(0,n.kt)(u,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"query-fact-records"},"Query Fact Records"),(0,n.kt)("p",null,"This is the simplest type of query. You just define the attributes which you need in the results,\nand you get all records directly from the database matching ",(0,n.kt)("a",{parentName:"p",href:"/docs/graphql/limits"},"limits"),", ",(0,n.kt)("a",{parentName:"p",href:"/docs/graphql/sorting"},"sorting"),"\nand ",(0,n.kt)("a",{parentName:"p",href:"/docs/graphql/filters"},"filters"),"."),(0,n.kt)("p",null,"Note that fact tables are typically long beasts, and querying the complete content of them not possible at all.\nSo in reality you can query only a small portion of data, and there is no good way to get the complete\ndataset just by querying the fact tables, even using ",(0,n.kt)("a",{parentName:"p",href:"/docs/graphql/limits"},"limits")," and offsets."),(0,n.kt)("p",null,"This type of query is useful in the following cases:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"query some specific sub-set of the data, with the very well-defined filters. For example, the last token transfers of specific address for today. The more precise filter you define, the better it will run. Date or time filters are essential in this case."),(0,n.kt)("li",{parentName:"ol"},"define ordering and query just the last records. This type of query should also take care about date / time filtering especially if you query archive data.")),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://graphql.bitquery.io/ide/Last-transactions-with-cost"},"Query example ")," to get the last transactions in the blockchain with the cost of them:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-graphql"},"query {\n  EVM(dataset: realtime network: bsc) {\n    Transactions(limit: {count: 100}\n    orderBy: [{descending: Block_Number} {descending: Transaction_Index}]) {\n      Block {\n        Time\n        Number\n      }\n      Transaction {\n        Hash\n        Cost\n      }\n    }\n  }\n}\n")))}d.isMDXComponent=!0}}]);